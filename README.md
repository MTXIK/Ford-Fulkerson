# Алгоритм Форда-Фалкерсона для поиска максимального потока

## Описание

Данная программа реализует алгоритм Форда-Фалкерсона для нахождения максимального потока в ориентированном графе. Граф задается в виде списков смежности, считываемых из бинарного файла. Программа принимает имя входного файла в качестве обязательного параметра и, опционально, имя выходного файла с помощью ключа `-o`. Если имя выходного файла не указано, результаты записываются в файл `output.txt` по умолчанию.

### Основные возможности программы:

1. **Нахождение максимального потока** между заданными источником и стоком.
2. **Вывод величины потока**.
3. **Отображение потока и пропускной способности** для каждого ребра графа.

## Требования

- **Компилятор C++**: Поддерживающий стандарт C++11 или выше (например, `g++`, `clang++`).
- **Операционная система**: Windows, Linux, macOS или любая другая ОС с поддержкой C++.

## Сборка

1. **Скачайте исходный код** программы и сохраните его в файл, например, `ford_fulkerson.cpp`.

2. **Откройте терминал** или командную строку и перейдите в директорию с исходным кодом.

3. **Скомпилируйте программу** с помощью компилятора C++. Например, используя `g++`:

   ```bash
   g++ -std=c++11 -o ford_fulkerson ford_fulkerson.cpp
   ```

   Где `ford_fulkerson.cpp` — имя файла с исходным кодом, а `ford_fulkerson` — имя создаваемого исполняемого файла.

## Использование

Запустите программу, передав в качестве обязательного аргумента имя входного бинарного файла. Опционально можно указать имя выходного файла с помощью ключа `-o`.

### Синтаксис

```bash
./ford_fulkerson <input_file.bm> [-o <output_file.txt>]
```

- `<input_file.bm>`: Имя входного бинарного файла, содержащего список ребер графа.
- `-o <output_file.txt>`: (Опционально) Имя выходного текстового файла. Если ключ `-o` не указан, результаты записываются в файл `output.txt` по умолчанию.

### Пример использования

**Без указания выходного файла (результаты будут записаны в `output.txt`):**

```bash
./ford_fulkerson graph.bm
```

**С указанием выходного файла:**

```bash
./ford_fulkerson graph.bm -o results.txt
```

### Интерфейс пользователя

После запуска программы, она запросит у пользователя ввод номеров исходной (истока) и конечной (стока) вершин:

```
Enter source vertex: 0
Enter sink vertex: 3
Choose output option:
1 - First to last vertex order
2 - Source to sink vertex order
Your choice: 1
```

После выбора опции, результаты будут записаны в указанный выходной файл.

### Опции вывода

1. **First to last vertex order**: Потоки записываются в порядке от первой до последней вершины.
2. **Source to sink vertex order**: Потоки записываются в порядке обхода BFS от источника к стоку.

## Формат входного файла

Входной файл должен быть бинарным и содержать список ребер графа с 16-битными целыми числами (`int16`). Структура файла следующая:

1. **Первое число (`int16`)**: Количество вершин `n` в графе.
2. **Далее следует перечисление ребер**: Каждое ребро задается тремя `int16` числами:
   - **Начальная вершина ребра** (`from`)
   - **Конечная вершина ребра** (`to`)
   - **Пропускная способность ребра** (`capacity`)

Если пропускная способность равна `0`, предполагается отсутствие ребра между соответствующими вершинами.

### Пример создания бинарного файла

Вот пример того, как можно создать бинарный файл с ребрами графа на языке C++:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdint>

int main() {
    int16_t numVertices = 4; // Число вершин
    // Список ребер: from, to, capacity
    std::vector<int16_t> edges = {
        0, 1, 100,
        0, 2, 100,
        1, 2, 1,
        1, 3, 100,
        2, 3, 100
    };
    
    std::ofstream outFile("graph.bm", std::ios::binary);
    if (!outFile) {
        std::cerr << "Не удалось открыть файл для записи." << std::endl;
        return 1;
    }
    
    outFile.write(reinterpret_cast<char*>(&numVertices), sizeof(numVertices));
    outFile.write(reinterpret_cast<char*>(edges.data()), edges.size() * sizeof(int16_t));
    
    outFile.close();
    return 0;
}
```

Этот код создаст бинарный файл `graph.bm`, содержащий граф с 4 вершинами и заданными ребрами.

## Формат выходного файла

Выходной файл представляет собой текстовый файл, содержащий следующую информацию:

1. **Величина максимального потока:**
   ```
   Value of maximum flow from <source> to <sink> vertices: <maxFlow>
   ```

2. **Потоки через рёбра:**
   ```
   Flow:
   (from, to, flow)
   (from, to, flow)
   ...
   ```

### Пример выходного файла

```
Value of maximum flow from 0 to 3 vertices: 200
Flow:
(0, 1, 100)
(0, 2, 100)
(1, 3, 100)
(2, 3, 100)
```

## Функциональность

- **Чтение из файла:** Программа открывает бинарный файл, считывает количество вершин и список ребер графа, строя списки смежности.
  
- **Ввод исходной и конечной вершин:** После загрузки графа, пользователь вводит номера исходной (истока) и конечной (стока) вершин.

- **Выполнение алгоритма Форда-Фалкерсона:** Программа находит максимальный поток от источника к стоку с помощью алгоритма Форда-Фалкерсона, используя поиск в ширину (BFS) для поиска аугментирующих путей.

- **Выбор опции вывода:** Пользователь может выбрать порядок записи потоков в выходной файл:
  - **1:** Потоки записываются в порядке от первой до последней вершины.
  - **2:** Потоки записываются в порядке обхода BFS от источника к стоку.

- **Запись результатов:** Максимальный поток и информация о потоках через рёбра записываются в указанный выходной файл.

- **Освобождение памяти:** После завершения работы, программа освобождает динамически выделенную память для рёбер.

## Тесты

Тестовые файлы находятся в папке `tests`. В этой папке вы найдете примеры бинарных файлов с графами различных типов, включая графы с разными пропускными способностями и различными конфигурациями ребер. Эти тесты помогут проверить корректность работы программы.

### Пример использования тестов

1. **Перейдите в папку с тестами:**

   ```bash
   cd tests
   ```

2. **Запустите программу с одним из тестовых файлов:**

   ```bash
   ../ford_fulkerson test1.bm -o result1.txt
   ```

3. **Следуйте инструкциям программы для ввода исходной и конечной вершин.**

4. **Просмотрите результаты в выходном файле:**

   ```bash
   cat result1.txt
   ```